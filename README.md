# Prac-2.4-2.5
# Практическая работа по алгоритмам
## Базовые рекурсивные функции вариант 1: Вычисление суммы цифр числа

### 1. Название задачи
**Вычисление суммы цифр числа с использованием рекурсии**

### 2. Описание работы алгоритма

Алгоритм вычисляет сумму цифр числа с помощью рекурсивного подхода. Основная идея заключается в последовательном отделении последней цифры числа и добавлении её к сумме оставшихся цифр.

**Принцип работы:**
- Базовый случай: если число равно 0, возвращается 0
- Рекурсивный случай: возвращается последняя цифра числа + сумма цифр оставшейся части числа

**Пример кода на Python для демонстрации алгоритма:**
```python
def sum_of_digits(n):
    # Базовый случай: если число равно 0, сумма цифр равна 0
    if n == 0:
        return 0
    # Рекурсивный случай: последняя цифра + сумма цифр оставшейся части
    return n % 10 + sum_of_digits(n // 10)
```
###3. Временная сложность алгоритма
O(log₁₀(n)), где n - исходное число

###4. Объяснение временной сложности алгоритма
Временная сложность определяется количеством цифр в исходном числе. Каждый рекурсивный вызов уменьшает число в 10 раз (убирается одна цифра). Количество цифр в числе n вычисляется по формуле ⌊log₁₀(n)⌋ + 1. Таким образом, алгоритм выполняет O(log₁₀(n)) операций, что соответствует количеству цифр в числе.

###5. Реализация задачи на различных языках программирования
Реализация на Python
```
python
def sum_of_digits(n):
    if n == 0:
        return 0
    return n % 10 + sum_of_digits(n // 10)
```
# Тестирование
```
num = 12345
print(f"Сумма цифр числа {num} равна {sum_of_digits(num)}")
```
Результат выполнения:
```
Сумма цифр числа 12345 равна 15
```
Реализация на C++
```
cpp
#include <iostream>
using namespace std;

int sum_of_digits(int n) {
    if (n == 0)
        return 0;
    return n % 10 + sum_of_digits(n / 10);
}

int main() {
    int num = 12345;
    cout << "Сумма цифр числа " << num << " равна " << sum_of_digits(num) << endl;
    return 0;
}
```
Результат выполнения:
```
Сумма цифр числа 12345 равна 15
```
```
Реализация на Java
java
public class SumOfDigits {
    public static int sumOfDigits(int n) {
        if (n == 0)
            return 0;
        return n % 10 + sumOfDigits(n / 10);
    }
    
    public static void main(String[] args) {
        int num = 12345;
        System.out.println("Сумма цифр числа " + num + " равна " + sumOfDigits(num));
    }
}
```
Результат выполнения:

```
Сумма цифр числа 12345 равна 15
```
6. Ответ на контрольный вопрос №10
Разница между обходом дерева в глубину (DFS) и в ширину (BFS):

1. Порядок обхода:

DFS (Depth-First Search): Обходит дерево вглубь, посещая всех потомков узла перед переходом к соседним узлам. Использует стратегию "последний пришел - первый вышел" (LIFO)

BFS (Breadth-First Search): Обходит дерево уровень за уровнем, посещая все узлы на текущей глубине перед переходом на следующий уровень. Использует стратегию "первый пришел - первый вышел" (FIFO)

2. Используемые структуры данных:

DFS: Использует стек (явный или неявный через рекурсию)

BFS: Использует очередь

3. Требования к памяти:

DFS: Требует O(h) памяти, где h - высота дерева

BFS: Требует O(w) памяти, где w - максимальная ширина дерева

4. Области применения:

DFS: Лучше подходит для:

Поиска путей в графах

Проверки связности

Топологической сортировки

Решения задач с возвратом (backtracking)

BFS: Лучше подходит для:

Поиска кратчайших путей в невзвешенных графах

Нахождения минимального количества шагов

Поиска в социальных сетях (поиск друзей на определенном расстоянии)

5. Полнота поиска:

BFS: Всегда находит решение, если оно существует (для конечных деревьев)

DFS: Может зациклиться на бесконечных деревьях без механизма отслеживания посещенных узлов

6. Эффективность:

DFS: Эффективен когда искомый элемент находится глубоко в дереве

BFS: Эффективен когда искомый элемент находится неглубоко или когда нужно найти кратчайший путь
